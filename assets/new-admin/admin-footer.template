

<footer class="footer" style="background-color: #f6f6f3">
    <p>
        Power by <a href="https://github.com/BapiGso/SMOE">SMOE</a>
    </p>
</footer>
<script>
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');

    var width = window.innerWidth;
    var height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // 创建绽放花瓣
    var petals = [];
    var petalCount = 30;
    var minSize = 15;
    var maxSize = 20;
    var minSpeedY = 0.5;
    var maxSpeedY = 1.5;
    var minSpeedX = -0.05;
    var maxSpeedX = 0.05;
    var colors = ['#FCF5F7', '#FEEEED', '#f5c4cb', '#decfd7', '#fff7ea'];

    for (var i = 0; i < petalCount; i++) {
        var speedY = Math.random() * (maxSpeedY - minSpeedY) + minSpeedY;
        var speedX = Math.random() * (maxSpeedX - minSpeedX) + minSpeedX;
        var petal = {
            x: Math.random() * width,
            y: Math.random() * height,
            size: Math.random() * (maxSize - minSize) + minSize,//花的直径
            color: colors[Math.floor(Math.random() * colors.length)],
            speedY: speedY,
            speedX: speedX,
            angle: Math.random() * Math.PI * 2,
            rad: 5,
            part: 6,
        };
        petals.push(petal);
    }

    // 循环绘制花瓣
    function draw() {
        ctx.clearRect(0, 0, width, height);
        for (var i = 0; i < petals.length; i++) {
            var petal = petals[i];
            ctx.fillStyle = petal.color;
            const x0 = petal.x + 0.7 * petal.size * Math.cos(( petal.part) / petal.rad);
            const y0 = petal.y + 0.7 * petal.size * Math.sin(( petal.part) / petal.rad);
            const x1 = petal.x + petal.size * Math.cos(( petal.part + 2 * petal.part / 6) / petal.rad);
            const y1 = petal.y + petal.size * Math.sin(( petal.part + 2 * petal.part / 6) / petal.rad);
            const x2 = petal.x + 0.7 * petal.size * Math.cos(( petal.part + 3 * petal.part / 6) / petal.rad);
            const y2 = petal.y + 0.7 * petal.size * Math.sin(( petal.part + 3 * petal.part / 6) / petal.rad);
            const x3 = petal.x + petal.size * Math.cos(( petal.part + 4 * petal.part / 6) / petal.rad);
            const y3 = petal.y + petal.size * Math.sin(( petal.part + 4 * petal.part / 6) / petal.rad);
            const x4 = petal.x + 0.7 * petal.size * Math.cos(( petal.part + petal.part) / petal.rad);
            const y4 = petal.y + 0.7 * petal.size * Math.sin(( petal.part + petal.part) / petal.rad);
            // petal
            ctx.beginPath();
            ctx.moveTo(petal.x, petal.y);
            ctx.quadraticCurveTo(x0, y0, x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.quadraticCurveTo(x4, y4, petal.x, petal.y);
            ctx.fill();
            ctx.closePath();
            //ctx.stroke();
            ctx.rotate(Math.PI)


            petal.y += petal.speedY;
            petal.angle += petal.speedX;  // 改变花瓣角度
            petal.x += Math.sin(petal.angle) * 2;  // 左右摇摆

            // 如果花瓣达到底部，则重新随机生成
            if (petal.y > height) {
                petal.y = 0 - petal.size;
                petal.x = Math.random() * width;
            }
        }
        requestAnimationFrame(draw);
    }

    draw();
</script>

</body>
</html>